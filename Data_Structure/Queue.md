# 큐 (Queue)

- 큐의 특성

    1. 스택과 비슷한 자료구조이나 큐의 경우 삭제 위치가 다름

    2. 선입선출구조 (FIFO; First-In-First-Out)

- 큐의 연산

    1. 삽입 : 큐의 뒤쪽(Rear)에 원소를 삽입 (ENQUEUE)

    2. 삭제 : 큐의 앞쪽(front)에서 원소를 삭제 (DEQUEUE)

    3. 생성 : 큐를 생성하는 연산 (CREATEQUEUE)

    4. 공백확인 : 큐의 공백여부를 판단 (ISEMPTY)

    5. 포화확인 : 큐의 포화상태를 판단 (ISFULL)

    6. 앞쪽 원소 확인 : 큐의 앞쪽에서 원소를 삭제하지 않고 반환 (QPEEK)

- 큐의 종류

    1. 선형 큐

        a. 1차원 배열을 이용한 큐

            - 큐의 크기 = 배열의 크기

            - front : 저장된 첫 번째 원소의 인덱스

            - rear : 저장된 마지막 원소의 인덱스

        b. 상태 표현

            - 초기 상태 : front = rear = -1

            - 공백 상태 : front = rear

            - 포화 상태 : rear = n-1 (n : 배열의 크기 / n-1 : 배열의 마지막 인덱스)

    2. 원형 큐

        a. 선형 큐의 문제점

            - 잘못된 포화상태 인식

        b. 해결방법

            - 매 연산이 이루어질 때마다 저장된 원소들의 배열을 앞으로 이동

            - 1차원 배열을 사용하되, 논리적으로 배열의 처음과 끝이 연결되어 있는 원형 큐의 형태를 사용

        c. 원형 큐의 구조

            - 초기 공백 상태 : front = rear = 0

            - INDEX 순환 : front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스 0으로 이동

            - 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 비워둠

    3. 우선순위 큐

        a. 특성

            - 우선순위를 가진 항목들을 저장하는 큐

            - FIFO의 순서가 아닌 우선순위가 높은 순서대로 삭제

        b. 적용 분야

            - 시뮬레이션 시스템

            - 네트워크 트래픽 제어

            - 운영체제의 테스크 스케쥴링

        c. 배열을 이용한 우선순위 큐 구현

            - 배열을 이용하여 자료 저장

            - 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치게 삽입

            - 가장 앞에 최고 우선순위의 원소가 위치

        d. 문제점

            - 배열을 사용하므로 삽입, 삭제 연산 시 기존 데이터의 재배치 발생

            - 해당 과정에서 소요되는 시간과 메모리 낭비가 큼

- 큐의 활용

    1. 버퍼

        a. 개념

            - 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 데이터를 보관하는 메모리 영역

            - 버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미

        b. 자료구조

            - 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용

            - 순서대로 입력, 출력, 전달되어야 하므로 FIFO 방식인 큐를 활용

- 큐를 활용한 알고리즘

    1. [BFS](https://github.com/Semibro/DataStructure_Algorithm/blob/main/Algorithm/BFS.md#%EB%84%88%EB%B9%84%EC%9A%B0%EC%84%A0%ED%83%90%EC%83%89-bfs)